<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Interactive Pond — Working Demo</title>
<style>
:root{
  --bg:#081018; --panel-bg: rgba(10,12,18,0.65); --muted:#bfc7d6;
}
html,body{height:100%;margin:0;background:radial-gradient(1200px 600px at 10% 10%, #071123 0%, var(--bg) 30%); color:#e6eef8; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;}
#app{width:100%;height:100vh;position:relative;overflow:hidden;}
#renderContainer{position:absolute;inset:0;}

.panel{
  position:absolute; left:18px; top:18px; width:320px; background:var(--panel-bg);
  border-radius:12px; padding:12px; box-shadow:0 6px 30px rgba(0,0,0,0.6);
  backdrop-filter:blur(6px); border:1px solid rgba(255,255,255,0.04);
}
.panel h2{margin:0 0 8px 0;font-size:16px;color:#fff}
.panel p{margin:0 0 12px 0;color:var(--muted);font-size:13px}
.panel .row{display:flex;align-items:center;gap:8px;margin-bottom:8px}
.panel label{min-width:110px;color:var(--muted);font-size:13px}
.panel input[type="range"]{flex:1}

#infoBox{
  position:absolute; right:18px; top:18px; width:340px; max-height:70vh; overflow:auto;
  background:linear-gradient(180deg, rgba(8,10,14,0.9), rgba(8,10,14,0.8));
  border-radius:12px; padding:14px; border:1px solid rgba(255,255,255,0.04); box-shadow:0 6px 30px rgba(0,0,0,0.6);
  display:none;
}
#infoBox h3{margin:0 0 6px 0;font-size:16px;color:#fff}
#infoBox p{margin:0;color:var(--muted);font-size:14px;line-height:1.45}

.legend{position:absolute;left:18px;bottom:18px;background:rgba(6,8,10,0.4);border-radius:10px;padding:10px 12px;border:1px solid rgba(255,255,255,0.03);color:var(--muted);font-size:13px;display:flex;gap:12px;align-items:center}
.legend .sw{width:12px;height:12px;border-radius:3px;display:inline-block}

.tooltip{position:absolute;pointer-events:none;background:rgba(0,0,0,0.75);color:#fff;padding:6px 8px;border-radius:6px;font-size:12px;transform:translate(-50%,-120%);white-space:nowrap;display:none;z-index:3000}
.credits{position:absolute;right:18px;bottom:18px;color:var(--muted);font-size:12px}

.btn{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px 10px;border-radius:8px;cursor:pointer;font-size:13px}
.btn:active{transform:translateY(1px)}

@media (max-width:760px){
  .panel{ width: calc(100% - 36px); left:18px; top:12px }
  #infoBox{ display:none !important }
}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.156.1/examples/jsm/"
  }
}
</script>
</head>
<body>
<div id="app">
  <div id="renderContainer"></div>

  <div class="panel" id="controls">
    <h2>Interactive Pond — Working Demo</h2>
    <p>Rotate the scene. Hover to highlight regions. Click to show info.</p>

    <div class="row"><label for="waterOpacity">Water opacity</label><input id="waterOpacity" type="range" min="0.05" max="1" step="0.01" value="0.7" /></div>
    <div class="row"><label for="algaeOpacity">Algae visibility</label><input id="algaeOpacity" type="range" min="0" max="1" step="0.01" value="0.85" /></div>
    <div class="row"><label for="highlightStrength">Highlight</label><input id="highlightStrength" type="range" min="0" max="1" step="0.05" value="0.6" /></div>
    <div class="row"><label for="timescale">Eutrophication</label><input id="timescale" type="range" min="0" max="1" step="0.01" value="0" /></div>

    <div class="row" style="margin-top:8px">
      <button id="resetBtn" class="btn">Reset view</button>
      <div style="flex:1"></div>
      <button id="toggleBubbles" class="btn">Toggle Bubbles</button>
    </div>

    <p style="margin-top:10px;font-size:12px;color:var(--muted)">Click parts to read about nitrate leaching and algal blooms.</p>
  </div>

  <div id="infoBox" aria-live="polite"></div>

  <div class="legend" aria-hidden="false">
    <div class="item"><span class="sw" style="background:#4fc3f7"></span>Water</div>
    <div class="item"><span class="sw" style="background:#d29b70"></span>Soil</div>
    <div class="item"><span class="sw" style="background:#6fcf97"></span>Algae</div>
  </div>

  <div class="credits">Three.js demo — interactive pond</div>
  <div class="tooltip" id="tooltip"></div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { SimplexNoise } from 'three/addons/math/SimplexNoise.js';

// ---------- Scene setup ----------
const container = document.getElementById('renderContainer');
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x071123, 0.03);

const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 200);
camera.position.set(8, 6, 10);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.target.set(0, 0.1, 0);

// lights
scene.add(new THREE.AmbientLight(0xffffff, 0.45));
const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(10,12,6); scene.add(dir);
scene.add(new THREE.HemisphereLight(0x88aaff, 0x082033, 0.35));

// ---------- Materials ----------
const topsoilMat = new THREE.MeshStandardMaterial({ color: 0xd29b70, roughness:0.85 });
const subsoilMat = new THREE.MeshStandardMaterial({ color:0xc68c5c, roughness:0.85 });
const rockMat = new THREE.MeshStandardMaterial({ color:0x888888, roughness:1.0 });
const waterMat = new THREE.MeshPhysicalMaterial({
    color:0x4fc3f7, roughness:0.1, metalness:0.03, transparent:true, opacity:0.7,
    transmission:0.75, ior:1.33, clearcoat:0.05, clearcoatRoughness:0.02
});
const algaeMat = new THREE.MeshStandardMaterial({ color:0x6fcf97, roughness:0.6, transparent:true, opacity:0.85 });
const fishMat = new THREE.MeshStandardMaterial({ color:0x9fb7c9, roughness:0.45 });
const deadFishMat = new THREE.MeshStandardMaterial({ color:0x4a4a4a, transparent:true, opacity:0.45 });

// ---------- Groups ----------
const pondGroup = new THREE.Group(); scene.add(pondGroup);
const grassGroup = new THREE.Group(); scene.add(grassGroup);
const interactiveMeshes = [];
const simplex = new SimplexNoise();

// ---------- Helpers ----------
function makeLopsidedBowl(outerRadius=6, innerRadius=3, depth=1.6, segments=128){
    const pts = [];
    pts.push(new THREE.Vector2(outerRadius, 0.12));
    pts.push(new THREE.Vector2(outerRadius*0.85, 0.07));
    pts.push(new THREE.Vector2((outerRadius+innerRadius)*0.5, -depth*0.15));
    pts.push(new THREE.Vector2(innerRadius*0.95, -depth*0.5));
    pts.push(new THREE.Vector2(innerRadius*0.5, -depth*0.85));
    pts.push(new THREE.Vector2(0, -depth));
    let geom = new THREE.LatheGeometry(pts, segments);
    let waterSurface, algaePatch, fishes=[], bubbleGroup;
    let waterVolume;

    const pos = geom.attributes.position;
    const v = new THREE.Vector3();
    for (let i=0; i<pos.count; i++){
        v.fromBufferAttribute(pos,i);
        const angle = Math.atan2(v.z, v.x);
        v.y += Math.cos(angle*3)*0.2 + (Math.random()-0.5)*0.02; // lopsided
        pos.setXYZ(i, v.x, v.y, v.z);
    }
    geom.computeVertexNormals();
    return geom;
}

// ---------- Create pond ----------
let waterSurface, algaePatch, fishes=[], bubbleGroup;
let waterVolume = new THREE.Mesh(
    new THREE.CylinderGeometry(3.5, 3.5, 1.0, 32),
    waterMat.clone()
);
waterVolume.position.y = -0.75;
pondGroup.add(waterVolume);

function createLopsidedPond(){
    const outerR = 6;
    const innerR = 3;
    pondGroup.clear();
    interactiveMeshes.length = 0;

    // Topsoil
    const topGeom = makeLopsidedBowl(6, 3, 1.6, 256);
    const topMesh = new THREE.Mesh(topGeom, topsoilMat);
    topMesh.name = 'Topsoil';
    topMesh.position.y = -0.5;
    pondGroup.add(topMesh); interactiveMeshes.push(topMesh);

    // Subsoil
    const subGeom = makeLopsidedBowl(6*0.97, 3*0.95, 1.7, 256);
    const subMesh = new THREE.Mesh(subGeom, subsoilMat);
    subMesh.name = 'Subsoil';
    subMesh.position.y = -0.9;
    pondGroup.add(subMesh); interactiveMeshes.push(subMesh);

    // Bedrock
    const rockGeom = makeLopsidedBowl(6*0.99, 3*0.6, 2.0, 256);
    const rockMesh = new THREE.Mesh(rockGeom, rockMat);
    rockMesh.name = 'Bedrock';
    rockMesh.position.y = -1.25;
    pondGroup.add(rockMesh); interactiveMeshes.push(rockMesh);

    // Water surface
    const waterRadius = 3.7;
    const waterGeom = new THREE.CircleGeometry(waterRadius, 128);
    waterGeom.rotateX(-Math.PI/2);
    waterSurface = new THREE.Mesh(waterGeom, waterMat.clone());
    waterSurface.position.y = -0.75;
    pondGroup.add(waterSurface); interactiveMeshes.push(waterSurface);
    waterSurface.userData.originalPositions = waterGeom.attributes.position.array.slice();

    // NEW: water volume (the “filling-ness”)
    const volHeight = 0.9;
    const volRadius = waterRadius * 0.98;
    waterVolume = new THREE.Mesh(
        new THREE.CylinderGeometry(volRadius, volRadius, volHeight, 48),
        waterMat.clone()
    );
    waterVolume.material.opacity = 0.35;    // subtle fill
    waterVolume.material.transparent = true;
    waterVolume.material.depthWrite = false; // avoids hiding things behind it
    waterVolume.position.y = waterSurface.position.y - volHeight/2 + 0.02;
    pondGroup.add(waterVolume);

    // Algae
    const algaeRadius = 2.0;
    const algaeGeom = new THREE.CircleGeometry(algaeRadius, 64);
    algaeGeom.rotateX(-Math.PI/2);
    algaePatch = new THREE.Mesh(algaeGeom, algaeMat.clone());
    algaePatch.position.y = waterSurface.position.y + 0.01;
    pondGroup.add(algaePatch); interactiveMeshes.push(algaePatch);


  // fish (create groups with userData)
  const fishCount = 14;
  for (let i=0;i<fishCount;i++){
    const fg = makeFish(0x9fb7c9);
    // random position inside circle (full 2π)
    const a = Math.random()*Math.PI*2;
    const r = Math.random() * (waterRadius*0.88);
    const x = Math.cos(a)*r;
    const z = Math.sin(a)*r;
    const y = waterSurface.position.y - (Math.random()*0.45 + 0.05);
    fg.position.set(x,y,z);
    fg.rotation.y = Math.random()*Math.PI*2;
    fg.userData = {
      isDead: false,
      swimSpeed: 0.03 + Math.random()*0.06,
      deathTime: Math.random()*0.85 + 0.15,
      id: i
    };
    pondGroup.add(fg);
    fishes.push(fg);
    interactiveMeshes.push(fg);
  }

  // grass around rim
//   grassGroup.clear();
//   const grassMat = new THREE.MeshStandardMaterial({ color: 0x2f6b34, roughness: 0.95 });
//   const grassCount = 12;
//   for (let i=0;i<grassCount;i++){
//     const t = i / grassCount * Math.PI*2;
//     const r = outerR + 0.12 + (Math.random()*0.25);
//     const x = Math.cos(t) * r;
//     const z = Math.sin(t) * r;
//     const h = 0.7 + Math.random()*0.5;
//     const bladeGeo = new THREE.PlaneGeometry(0.18, h, 1, 2);
//     bladeGeo.translate(0, h/2, 0);
//     const blade = new THREE.Mesh(bladeGeo, grassMat.clone());
//     blade.position.set(x, -0.12 + (Math.random()*0.08), z);
//     blade.lookAt(0,0,0);
//     blade.rotateX(THREE.MathUtils.degToRad(-8 + Math.random()*14));
//     blade.name = 'Grass';
//     grassGroup.add(blade);
//     interactiveMeshes.push(blade);
//   }

  // bubbles
  bubbleGroup = new THREE.Group();
  const bubbleGeo = new THREE.SphereGeometry(0.035, 8, 6);
  const bubbleMat = new THREE.MeshStandardMaterial({ color: 0xcfe9ff, transparent:true, opacity:0.75, roughness:0.2 });
  for (let i=0;i<60;i++){
    const b = new THREE.Mesh(bubbleGeo, bubbleMat.clone());
    const a = Math.random()*Math.PI*2;
    const r = Math.random()* (waterRadius*0.8);
    b.position.set(Math.cos(a)*r, waterSurface.position.y - Math.random()*0.5, Math.sin(a)*r);
    b.scale.setScalar(0.6 + Math.random()*1.4);
    b.userData.vy = 0.002 + Math.random()*0.005;
    bubbleGroup.add(b);
  }
  pondGroup.add(bubbleGroup);
}

// ---------- Riparian plants with roots ----------
const plantGroup = new THREE.Group();
scene.add(plantGroup);

function createPlantsAroundPond(count = 25){
    plantGroup.clear();
    const plantMat = new THREE.MeshStandardMaterial({ color: 0x2f6b34, roughness: 0.95 });
    const rootMat = new THREE.MeshStandardMaterial({ color: 0x8b5e3c, roughness: 0.9 });

    const waterRadius = waterSurface.geometry.parameters.radius || 3.7;
    const plantOuterRadius = waterRadius + 0.3;

    for(let i=0;i<count;i++){
        const angle = Math.random()*Math.PI*2;
        const r = plantOuterRadius + (Math.random()*0.3);
        const x = Math.cos(angle)*r;
        const z = Math.sin(angle)*r;

        // stem/leaf
        const stemHeight = 0.5 + Math.random()*0.5;
        const stemGeo = new THREE.CylinderGeometry(0.05, 0.05, stemHeight, 6);
        const stem = new THREE.Mesh(stemGeo, plantMat.clone());
        stem.position.set(x, -0.5 + stemHeight/2, z);
        plantGroup.add(stem);
        interactiveMeshes.push(stem);

        // root
        const rootLength = 0.3 + Math.random()*0.2;
        const rootGeo = new THREE.CylinderGeometry(0.03, 0.03, rootLength, 6);
        const root = new THREE.Mesh(rootGeo, rootMat.clone());
        root.position.set(x, -0.5 - rootLength/2, z);
        plantGroup.add(root);
        interactiveMeshes.push(root);
    }
}

// ---------- Nitrate particles (leaching into pond centre) ----------

function createNitrateMolecule() {
    const group = new THREE.Group();

    // Nitrogen atom (blue)
    const nitrogen = new THREE.Mesh(
        new THREE.SphereGeometry(0.08, 16, 16),
        new THREE.MeshStandardMaterial({ color: 0x0000ff })
    );
    group.add(nitrogen);

    // Oxygen atoms (red)
    const oxyMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
    const radius = 0.2;
    for (let i = 0; i < 3; i++) {
        const angle = (i / 3) * Math.PI * 2;
        const oxygen = new THREE.Mesh(
            new THREE.SphereGeometry(0.06, 16, 16),
            oxyMat
        );
        oxygen.position.set(
            Math.cos(angle) * radius,
            0,
            Math.sin(angle) * radius
        );
        group.add(oxygen);
    }

    return group;
}

const nitrates = [];

function createNitrates(count) {
    nitrates.forEach(n => scene.remove(n));
    nitrates.length = 0;

    for (let i = 0; i < count; i++) {
        const nitrate = createNitrateMolecule();

        // Spawn near water edge (~radius 3.7–4), slightly above roots
        const angle = Math.random() * Math.PI * 2;
        const r = 3.7 + Math.random() * 0.3;
        nitrate.position.set(
            Math.cos(angle) * r,
            Math.random() * 0.1 - 0.6, // just under surface at edge
            Math.sin(angle) * r
        );

        // Movement: slightly downward + drift inward (towards pond centre)
        nitrate.userData.speedY = -(0.002 + Math.random() * 0.002); // downward
        nitrate.userData.driftX = -(nitrate.position.x) * 0.0005;   // pull toward x=0
        nitrate.userData.driftZ = -(nitrate.position.z) * 0.0005;   // pull toward z=0

        scene.add(nitrate);
        nitrates.push(nitrate);
    }
}

createNitrates(30);

function updateNitrates() {
    nitrates.forEach(n => {
        // Apply motion
        n.position.y += n.userData.speedY;
        n.position.x += n.userData.driftX;
        n.position.z += n.userData.driftZ;

        // If too deep, respawn at edge again
        if (n.position.y < -1) {
            const angle = Math.random() * Math.PI * 2;
            const r = 3.7 + Math.random() * 0.3;

            n.position.set(
                Math.cos(angle) * r,
                Math.random() * 0.2 - 0.6, // near surface edge
                Math.sin(angle) * r
            );

            n.userData.speedY = -(0.002 + Math.random() * 0.002);
            n.userData.driftX = -(n.position.x) * 0.0005;
            n.userData.driftZ = -(n.position.z) * 0.0005;
        }
    });
}




// ---------- fish maker (slim-profile body + tail + eyes) ----------
function makeFish(color=0x9fb7c9){
  const g = new THREE.Group();
  const body = new THREE.Mesh(new THREE.SphereGeometry(0.16, 12, 12), fishMat.clone());
  body.material.color.setHex(color);
  body.scale.set(1.4, 0.85, 0.8);
  g.add(body);

  const tail = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.18, 12), body.material.clone());
  tail.position.x = -0.22;
  tail.rotation.z = Math.PI;
  g.add(tail);

  const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
  const eye = new THREE.Mesh(new THREE.SphereGeometry(0.03, 8, 8), eyeMat);
  eye.position.set(0.08, 0.03, 0.06);
  g.add(eye);
  const eye2 = eye.clone(); eye2.position.z = -0.06; g.add(eye2);

  return g;
}

// ---------- Interactivity ----------
const ray = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const tooltip = document.getElementById('tooltip');
const infoBox = document.getElementById('infoBox');

const infoData = {
  'Water': { title:'Pond water', text: 'Water receives runoff. High nitrate leads to algal growth and oxygen loss.' },
  'Topsoil': { title:'Topsoil', text: 'Upper soil layer where plants grow and intercept runoff.' },
  'Subsoil': { title:'Subsoil', text: 'Subsoil stores water and nutrients; influences leaching.' },
  'Bedrock': { title:'Bedrock', text: 'Rock layer — groundwater pathways may transport dissolved nutrients.' },
  'Algae': { title:'Algal bloom', text: 'Excess nutrients (N/P) cause algal blooms, reducing oxygen and harming life.' },
  'Grass': { title:'Riparian vegetation', text: 'Vegetation filters runoff and stabilizes banks.' },
  'Fish': { title:'Fish', text: 'Fish depend on oxygen; eutrophication can cause die-offs.' }
};

let hovered = null;
function getTopLevel(object){
  // climb up groups to a named parent
  let o = object;
  while (o && !o.name && o.parent) o = o.parent;
  return o;
}

function onMove(e){
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  ray.setFromCamera(mouse, camera);
  const hits = ray.intersectObjects(interactiveMeshes, true);
  if (hits.length>0){
    let mesh = getTopLevel(hits[0].object);
    if (hovered !== mesh){
      if (hovered) clearHighlight(hovered);
      hovered = mesh;
      setHighlight(mesh, parseFloat(document.getElementById('highlightStrength').value) || 0.6);
    }
    tooltip.style.display = 'block';
    tooltip.style.left = (e.clientX)+'px';
    tooltip.style.top = (e.clientY - 10)+'px';
    const key = infoData[mesh.name] ? mesh.name : (mesh.userData && mesh.userData.isDead !== undefined ? 'Fish' : mesh.name);
    tooltip.innerText = (infoData[key] && infoData[key].title) ? infoData[key].title : mesh.name;
  } else {
    if (hovered) clearHighlight(hovered);
    hovered = null;
    tooltip.style.display = 'none';
  }
}

function onClick(e){
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  ray.setFromCamera(mouse, camera);
  const hits = ray.intersectObjects(interactiveMeshes, true);
  if (hits.length>0){
    const mesh = getTopLevel(hits[0].object);
    const key = infoData[mesh.name] ? mesh.name : (mesh.userData && mesh.userData.isDead !== undefined ? 'Fish' : mesh.name);
    const data = infoData[key] || { title: mesh.name, text: 'No information available.' };
    infoBox.innerHTML = `<h3>${data.title}</h3><p>${data.text}</p>`;
    infoBox.style.display = 'block';
  } else {
    infoBox.style.display = 'none';
  }
}

function setHighlight(mesh, strength=0.6){
  if (!mesh || !mesh.material) return;
  mesh.userData._orig = {
    emissive: mesh.material.emissive ? mesh.material.emissive.clone() : new THREE.Color(0x000000),
    emissiveIntensity: mesh.material.emissiveIntensity || 0
  };
  if (mesh.material.emissive) mesh.material.emissive.set(0xffffff);
  mesh.material.emissiveIntensity = strength;
}
function clearHighlight(mesh){
  if (!mesh || !mesh.material) return;
  if (mesh.userData && mesh.userData._orig){
    if (mesh.material.emissive) mesh.material.emissive.copy(mesh.userData._orig.emissive);
    mesh.material.emissiveIntensity = mesh.userData._orig.emissiveIntensity;
    delete mesh.userData._orig;
  } else {
    if (mesh.material.emissive) mesh.material.emissive.set(0x000000);
    mesh.material.emissiveIntensity = 0;
  }
}

// ---------- Water wave update ----------
let time = 0;
function updateWater(dt){
  if (!waterSurface) return;
  time += dt * 0.6;
  const pos = waterSurface.geometry.attributes.position;
  const arr = pos.array;
  const orig = waterSurface.userData.originalPositions;
  for (let i=0;i<arr.length;i+=3){
    const ox = orig[i], oy = orig[i+1], oz = orig[i+2];
    const n = simplex.noise3d(ox*0.25, oz*0.25, time*0.6);
    arr[i+1] = oy + n * 0.06;
  }
  pos.needsUpdate = true;
  waterSurface.geometry.computeVertexNormals();
}

// ---------- bubbles ----------
function updateBubbles(){
  if (!bubbleGroup) return;
  bubbleGroup.children.forEach(b=>{
    b.position.y += b.userData.vy;
    b.material.opacity = 0.6 + 0.35*Math.sin(performance.now()*0.002 + (b.userData.vy*1000));
    if (b.position.y > (waterSurface.position.y + 0.05)){
      const a = Math.random()*Math.PI*2;
      const r = Math.random()* (waterSurface.geometry.parameters.radius || 2.8) * 0.8;
      b.position.set(Math.cos(a)*r, waterSurface.position.y - 0.5 - Math.random()*0.15, Math.sin(a)*r);
    }
  });
}

// ---------- fish behaviour ----------
function updateFishes(){
  fishes.forEach(f=>{
    if (!f.userData) return;
    if (!f.userData.isDead){
      // simple wandering
      const t = performance.now()*0.001 * f.userData.swimSpeed;
      f.position.x += Math.cos(t + f.userData.id) * 0.002 * (0.8 + f.userData.swimSpeed);
      f.position.z += Math.sin(t*0.9 + f.userData.id) * 0.002 * (0.8 + f.userData.swimSpeed);
      // keep inside water radius
      const dist = Math.sqrt(f.position.x*f.position.x + f.position.z*f.position.z);
      const maxR = (waterSurface.geometry.parameters.radius || 2.9) - 0.08;
      if (dist > maxR){
        const ang = Math.atan2(f.position.z, f.position.x);
        f.position.x = Math.cos(ang) * (maxR - 0.02);
        f.position.z = Math.sin(ang) * (maxR - 0.02);
      }
      // small tail wiggle if tail exists (child index 1 usually)
      if (f.children[1]) f.children[1].rotation.y = Math.sin(performance.now()*0.01 + f.userData.id)*0.6;
    } else {
      // dead -> slowly sink + fade
      f.position.y -= 0.002;
      f.children.forEach(ch=>{
        if (ch.material && ch.material.opacity !== undefined){
          ch.material.opacity = Math.max(0, (ch.material.opacity || 1) - 0.001);
        }
      });
    }
  });
}

// ---------- Pond state (timescale -> algae + fish die) ----------
function updatePondState(value){
  if (!algaePatch) return;
  // algae opacity and scale
  const algaeMaxOpacity = 0.95;
  algaePatch.material.opacity = Math.min(algaeMaxOpacity, 0.5 + value*0.5);
  const minR = 0.8, maxR = (waterSurface.geometry.parameters.radius || 2.8) * 1.1;
  const rcur = minR + (maxR - minR)*value;
  algaePatch.scale.set(rcur/minR, rcur/minR, 1);

  // fish die progressively
  fishes.forEach(f=>{
    if (!f.userData.isDead && value >= f.userData.deathTime){
      f.userData.isDead = true;
      f.name = 'Fish';
      // swap to dead material
      f.traverse(node=>{
        if (node.isMesh){
          node.material = deadFishMat.clone();
        }
      });
    }
  });
}

// ---------- UI wiring ----------
document.getElementById('waterOpacity').addEventListener('input', e=>{
  const v = parseFloat(e.target.value);
  if (waterSurface) waterSurface.material.opacity = v;
  if (waterVolume) waterVolume.material.opacity = Math.min(0.65, v*0.35);
});
document.getElementById('algaeOpacity').addEventListener('input', e=>{
  const v = parseFloat(e.target.value);
  if (algaePatch) algaePatch.material.opacity = v;
});
document.getElementById('highlightStrength').addEventListener('input', e=>{
  if (hovered){ clearHighlight(hovered); setHighlight(hovered, parseFloat(e.target.value)); }
});
document.getElementById('timescale').addEventListener('input', e=>{
  updatePondState(parseFloat(e.target.value));
});
document.getElementById('resetBtn').addEventListener('click', ()=>{
  controls.reset();
  camera.position.set(8,6,10);
  controls.target.set(0,0.1,0);
  document.getElementById('timescale').value = 0;
  // rebuild and reset
  createLopsidedPond();
  createPlantsAroundPond();
  createNitrates(30);
  updatePondState(0);
});
let bubblesEnabled = true;
document.getElementById('toggleBubbles').addEventListener('click', (ev)=>{
  bubblesEnabled = !bubblesEnabled;
  ev.target.innerText = bubblesEnabled ? 'Toggle Bubbles' : 'Bubbles Off';
  if (bubbleGroup) bubbleGroup.visible = bubblesEnabled;
});

// ---------- ray listeners ----------
renderer.domElement.addEventListener('mousemove', onMove, { passive:true });
renderer.domElement.addEventListener('click', onClick);

// ---------- resize ----------
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ---------- Make initial pond ----------
createLopsidedPond();
createPlantsAroundPond();

// ---------- animation loop ----------
let last = performance.now();
(function loop(){
  const now = performance.now();
  const dt = (now - last)/1000;
  last = now;

  updateWater(dt);
  if (bubbleGroup && bubblesEnabled) updateBubbles();
  updateFishes();
  updateNitrates();

  controls.update();
  renderer.render(scene, camera);
  
  requestAnimationFrame(loop);
})();

// small keyboard helper
window.addEventListener('keydown', e=>{
  if (e.key === 'i') infoBox.style.display = infoBox.style.display === 'block' ? 'none' : 'block';
});
</script>
</body>
</html>